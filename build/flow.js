!function(t,e){if("object"==typeof exports&&"object"==typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var o=e();for(var i in o)("object"==typeof exports?exports:t)[i]=o[i]}}(global,(()=>(()=>{"use strict";var t={d:(e,o)=>{for(var i in o)t.o(o,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:o[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};function o(){const t=this;if(console.log("Starting flow"),t.flowRunning)return;if(t.flowRunning=!0,0===t.pipes.events.length){const e=t.pipes.targets[0];return void i.call(t,0,e)}const e=t.pipes.events;for(const o of e)i.call(t,-1,o)}function i(t,e,...o){console.log("Next target:"),console.log(e);const i=this;function s(){console.log(e.target.name,"used callback"),r.call(i,t+1,...Array.from(arguments))}const n=[...o,...e.params];n.push(s),console.log(e.target.name,"props",n);const l=e.target.apply({},n);"object"==typeof l&&l instanceof Promise&&l.then(((...t)=>s.call(null,...Array.from(t))))}function r(t,...e){console.log("next:",t),console.log("args:",arguments);const o=this.pipes.targets[t];if(!o||!o.target)return this.flowRunning=!1,this.promisified.isPromised&&(this.promisified.resolve(...e),this.promisified.isPromised=!1),console.log("End of flow at",t);i.call(this,t,o,...e)}function s(t,e,o){const i={direction:t,target:e,params:o};"function"!=typeof e&&function(t){const e=typeof t;return!(t&&"object"===e&&t.then&&"function"==typeof t.then||null!=t&&"function"==e)}(e)&&(i.target=async()=>e),"object"==typeof e&&"function"==typeof e.then&&(i.target=t=>e.then(t));const r=this;switch(i.direction){case"init":if(!function(t){try{return Reflect.construct(String,[],t),!0}catch(t){return!1}}(e))throw new Error("Flow target is not a constructor!");const t=new e(...o);r.pipes.init.push(t);break;case"from":console.log("from added for:",i),r.pipes.events.push(i);break;case"to":r.pipes.targets.push(i);break;default:console.warn("WARNING: Flow has received an unknown pipe direction. Please post a bug to the author about this.")}return console.log(`Added .${t}(${e.name||"anonymous"})`),this}t.r(e),t.d(e,{Flow:()=>n});class n{thread(){return new n}static use(t,e){if(this.modules[t])throw new Error(t+" collides with existing Flow module or property.");this.modules[t]=e}constructor(){return this.pipes={init:[],events:[],targets:[]},this.flowRunning=!1,this.promisified={isPromised:!1,resolve:()=>{},reject:()=>{}},this.init=function(t){return s.call(this,"init",t,Array.from(arguments).slice(1))},this.to=function(t){return s.call(this,"to",t,Array.from(arguments).slice(1))},this.from=function(t){return s.call(this,"from",t,Array.from(arguments).slice(1))},this.run=function(){if(this.promisified.isPromised)return new Promise(((t,e)=>{this.promisified.resolve=t,this.promisified.reject=e,o.call(this)}));o.call(this)},this.waitFor=function(t){return s.call(this,"waitFor",t,Array.from(arguments).slice(1))},this.promisify=()=>(this.promisified.isPromised=!0,this),this.modules={},this.modules=this.constructor.modules,new Proxy(this,{get:function(t,e){return Reflect.has(t,e)?Reflect.get(t,e):Reflect.has(t.modules,e)?t.modules[e]:void 0}})}}return n.modules={},e})()));